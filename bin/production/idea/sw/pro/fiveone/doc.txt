1000000	11110100001001000000

比它 大的第一个 有且只有5个1的 二进制数  ，从左向右将第一个0替换为1，满5个1后，剩余部分的1替换为0
11111000000000000000

只有5个1时，下一个5个1：
	从右面开始将第一个1与 它右面第一个0交换，交换后将这个1后面所有的1，依次与结尾处的0交换
	100000000100000111000---> 100000000100001110000	---> 100000000100001010001	---> 100000000100001000011

比它小的第一个 有且只有5个1的 二进制数 ,从左向右将第六个1及其后的1替换为0.
11110100000000000000

Start:101101110100000（23456）
		101101100000000
first:  101110000000001（23553）

Start:1100001101010000（50000）
first:  1100001110000000（50048）
124816


[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1]
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1]

Start:1100111
Start:1011110
Start:1010111

X 是区间(M,N)中十进制的整数，M和N取值范围1<=M<N<=10000000000,X可以转换为二进制数，在这些二进制数中找出那些有且只有5个1组成二进制B
输出：大于M的第一个Bmin，小于N的最后一个Bmax，Bmin和Bmax之间共有多少个B
例如 M=20 N=59，那么输出：#索引 31 55 1
当没有最小最大的51数时，输出 #索引 -1 -1 0
例如 M=1 N=30，那么输出：#索引 -1 -1 0
1秒内完成，30个Testcase，
Testcase 

1.整数在转化为二进制后，有三种情况：

	A. 1的个数小于5
	B. 1的个数大于5
	C. 1的个数等于5

计算二进制数中的1的个数：
	当A时，在低位上(数组的右侧)补1，这时比原数大
		求最小数时，此时即是最小数
		求最大数时，此时数比边界值上限还大,需要求前一个51
			
	当B时，去除低位上(数组的右侧)多余的1，这时的数比原数小
		求最小数时，此时数比边界值下限还小,需要求后一个51
		求最大数时，此时即是最大数
	当C时，
		求后一个51，从右向左找到第一个‘01’，交换成‘10’，将‘10’后面的数组元素进行由小到大重新排序
		求前一个51，从右向左找到第一个‘10’，交换成‘01’，将‘01’后面的数组元素进行由大到小重新排序

2.整数区间
	A. 1 ~ 10
	B. 1 ~ 100
	C. 1 ~ 10000
	D. 1000 ~ 1000000
	E. 100000 ~ 3000000
	F. 1 ~ 5000000
	G. 5000 ~ 5000000
	H. 10000000 ~ 70000000
	I. 1000000000 ~ 1100000000
	J. 1 ~ 10000000000